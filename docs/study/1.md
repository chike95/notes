# 软硬结合-从零打造物联网

## 一、项目介绍

搭建云服务器，把整个从硬件、到云服务器，最终界面呈现踏踏实实地走一回，打通起来

### 1.1 相关技术

dht11 esp8266 express 前端

### 1.2 参考教程

软硬结合-从零打造物联网

项目地址：<https://www.bilibili.com/video/BV16L411n7Pi>

教程网址：<https://www.scaugreen.cn/posts/44755/>

GitHub：<https://github.com/alwxkxk/soft-and-hard>


## 二、基础知识

### 2.1 NodeMCU

esp8266

![Alt text](./img/esp8266_devkit_horizontal-01.png)



### 2.2 开发环境

Arduino

官网下载地址: <https://www.arduino.cc/en/software>

驱动安装：ch340

扩展开发板网址: <http://arduino.esp8266.com/stable/package_esp8266com_index.json>

安装：文件-首选项

![Alt text](./img/arduino_json.png)

需求安装梯子访问，国内网络安装不了，解决办法：<https://www.scaugreen.cn/posts/10960>



### 2.3 数据获取

使用esp8266 获取dht11 数据

![Alt text](./img/wsd.png)

#### 参考视频：<https://www.bilibili.com/video/BV15A4y1D7Bh>

#### 安装库文件

![Alt text](./img/dht11_lib.png)

#### 代码：
```c
#include <DHT.h>      // 1.调用dht11驱动库
#define DHTPIN D4     // 2.定义D4（GPIO2）口
//#define DHTPIN 2
#define DHTTYPE DHT11 // 3.说明模块类型dht11

DHT dht(DHTPIN, DHTTYPE);


void setup() {
  // put your setup code here, to run once:
  dht.begin();  // 开始测量
  Serial.begin(9600);   // 打开串口，设置波特率
}

void loop() {
  // put your main code here, to run repeatedly:
  delay(200); 
  float h = dht.readHumidity();
  float t = dht.readTemperature();

  Serial.print("当前温度：");
  Serial.print(t);
  Serial.println("℃");
  Serial.print("当前湿度：");
  Serial.print(h);
  Serial.println("%");

  delay(2000);
}
```

#### 输出

![Alt text](./img/dht11_code.png)

### 2.4 调试助手

开一个cmd窗口，输入：telnet 127.0.0.1 4567，连接服务器



## 三、案例实现1

1.使用网络调试助手来替代服务器端程序，让NodeMCU与网络调试助手通信，网络调试助手接收来自于NodeMCU的数据以及向NodeMCU发送控制命令控制开关灯。

2.使用NodeMCU与服务器端程序通信，服务器端程序接收来自于NodeMCU的数据以及向NodeMCU发送控制

3.使用前端界面进行通信

### 3.1 硬件程序

#### 设计思路

让NodeMCU与服务器端程序通信，服务器端程序接收来自于NodeMCU的数据以及向NodeMCU发送控制命令控制开关灯。在编写服务器程序前，我们使用网络调试助手来 等效替换 我的服务器端程序，进行前期的想法验证，探索验证通过网络通信确实能控制NodeMCU。

ESP8266之WiFiClient库学习：<https://blog.csdn.net/qq_41477556/article/details/112366202>

#### 程序代码

```c
//如果是nodemcu V3版，需要另外定义LED引脚
#define LED_BUILTIN 2 
#include <ESP8266WiFi.h>
//必须修改：填写你的WIFI帐号密码
const char* ssid = "ziroom601";
const char* password = "ziroomer002";

const char* host = "192.168.0.108";
const int port = 15002;//tcp使用端口

const char* id = "1234abcd";
int tick = 1000;

WiFiClient client;  //建立WiFi客户端对象

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  pinMode(LED_BUILTIN, OUTPUT);
  //连接WIFI
  WiFi.begin(ssid, password);
  //设置读取socket数据时等待时间为100ms（默认值为1000ms，会显得硬件响应很慢）
  client.setTimeout(100);

  //等待WIFI连接成功
  while (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi connecting...");
    delay(500);
  }
  Serial.println("WiFi connected!.");
}

void loop() {
  // put your main code here, to run repeatedly:
  if (client.connect(host, port))
  {
    // TCP连接成功
    Serial.println("host connected!");
    client.println("TCP client connected!");
  }
  else
  {
    // TCP连接异常
    Serial.println("host connecting...");
    delay(500);
  }

  while (client.connected()) {
    //      接收到TCP数据
    if (client.available())
    {
      String line = client.readStringUntil('\n');
      if (line == "1") {
        // 如果接收到1，就代表开灯
        Serial.println("command:open led.");
        // 设置该引脚为低电平
        digitalWrite(LED_BUILTIN, LOW);
      }
      else if (line == "0") {
        // 如果接收到0，就代表关灯
        Serial.println("command:close led.");
        // 设置该引脚为高电平
        digitalWrite(LED_BUILTIN, HIGH);
      }else{
        Serial.print("receive:"); 
        Serial.println(line); 
      }
    }
  }
}

```

### 3.2 前端页面

#### 3.2.1 页面结构

页面结构主要分成三个部分：

- 1 标题

- 2 设备信息

  - 地址

  - 状态（0/1）

- 3 控制按钮

    - 开灯

    - 关灯

![Alt text](./img/ledcontrol.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>案例实现：网页控制小灯</title>
</head>
<body>
    <h1>网页点亮小灯</h1>
    <div class="info">
        <div>设备地址：<span id="equipment-addr"></span></div>
        <div>设备状态：<span id="equipment-status"></span></div>
    </div>
    <div class="control-btn">
        <button id="open-btn">开灯</button>
        <button id="close-btn">关灯</button>
    </div>
</body>
</html>
```

#### 3.2.2 逻辑处理

控制按钮：定义开/关灯函数，将其绑定到按钮上，点击后发送ajax请求

设备信息：HTTP 轮询：每一秒发起次请求，获取设备地址和esp8266的返回状态码（0/1），并将其显示在页面上

```js
<script>
    // 开灯
    function open() {
        let XHR = new XMLHttpRequest()
        XHR.open('GET', '/open')
        XHR.send()
    }

    // 关灯
    function close() {
        let XHR = new XMLHttpRequest()
        XHR.open('GET', '/close')
        XHR.send()
    }

    // 绑定按钮事件
    document.getElementById('open-btn').onclick = open
    document.getElementById('close-btn').onclick = close

    // 获取数据
    function genData() {
        console.log("hello");
        let XHR = new XMLHttpRequest()
        XHR.open('GET', '/data')
        XHR.onload = function () {
            let result = XHR.response
            let msg = JSON.parse(result)
            console.log(msg)
            document.getElementById('equipment-addr').innerHTML = msg.addr
            document.getElementById('equipment-status').innerHTML = msg.status
        }
        XHR.send()
    }

    setInterval(genData, 1000)
</script>
```


### 3.3 后端服务

#### 3.3.1 tcp服务

建立tcp服务器，获取-回送数据到esp8266

```js
const net = require('net')
const HTTP_HOST = '0.0.0.0'
const TCP_PORT = 15002

let tcpClient = null

// 创建TCP服务
var tcpServer = net.createServer((socket) => {
    //connect
    var addr = socket.remoteAddress + ':' + socket.remotePort
    console.log(addr, " connect.")
    socket.addr = addr
    tcpClient = socket

    // data
    socket.on('data', (data) => {
        // 获取客户端发送的数据
        tcpClient.lastData = data.toString()
        console.log('客户端发来数据：', tcpClient.lastData)
        // 向客户端发送数据
        socket.write('recieved: ' + tcpClient.lastData)
    })

    // close
    socket.on('close', () => {
        console.log('客户端断开连接')
    })

})

tcpServer.on('error', (err) => {
    console.log('tcpServer error', err)
})

tcpServer.listen(TCP_PORT, () => {
    console.log('tcpServer 监听端口：', TCP_PORT)
})
```


#### 3.3.2 http服务

根据不同请求，响应不同内容到页面

```js
const http = require('http')
const fs = require('fs')

const HTTP_PORT = 15001

// 创建HTTP服务
const httpServer = http.createServer((req, res) => {
    console.log(req.method, req.url);
    switch (req.url) {
        case '/':
            res.end(fs.readFileSync('./index.html'))
            break
        case '/data':
            var addr = "无连接";
            if (tcpClient && tcpClient.addr) {
                addr = tcpClient.addr
            }
            var status = genData() || "无数据";
            var result = JSON.stringify({ addr: addr, status: status })
            res.end(result)
            break
        case '/open':
            openLed()
            res.end("opend")
            break
        case '/close':
            closeLed()
            res.end("closed")
            break
        default:
            res.writeHead(400);
            res.end();
            break;
    }
})

httpServer.listen(HTTP_PORT, HTTP_HOST, () => {
    console.log('httpServer 监听端口：', HTTP_PORT)
})
```

#### 3.3.2 处理函数

```js
// 处理函数
function openLed() {
    if (tcpClient) {
        tcpClient.write('1')
    }
}

function closeLed() {
    if (tcpClient) {
        tcpClient.write('0')
    }
}

function genData() {
    if (tcpClient) {
        console.log("gendata");
        return tcpClient.lastData
    }
}

```

## 四、优化方案

### 4.1 Bootstrap


### 4.2 Express


### 4.3 Echarts

### 4.4 Websocket

### 4.5 Mysql

## 五、案例实现2



## 六、云部署