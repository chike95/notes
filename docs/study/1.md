# 软硬结合-从零打造物联网

## 一、项目介绍

搭建云服务器，把整个从硬件、到云服务器，最终界面呈现踏踏实实地走一回，打通起来

### 1.1 相关技术

dht11 esp8266 express 前端

### 1.2 参考教程

软硬结合-从零打造物联网

项目地址：<https://www.bilibili.com/video/BV16L411n7Pi>

教程网址：<https://www.scaugreen.cn/posts/44755/>

GitHub：<https://github.com/alwxkxk/soft-and-hard>


## 二、基础知识

### 2.1 NodeMcu


### 2.2 开发环境

Arduino

官网下载地址: <https://www.arduino.cc/en/software>

驱动安装：ch340

扩展开发板网址: <http://arduino.esp8266.com/stable/package_esp8266com_index.json>

安装：文件-首选项

![Alt text](./img/arduino_json.png)

需求安装梯子访问，国内网络安装不了，解决办法：<https://www.scaugreen.cn/posts/10960>



### 2.3 数据获取

使用esp8266 获取dht11 数据

![Alt text](./img/wsd.png)

#### 参考视频：<https://www.bilibili.com/video/BV15A4y1D7Bh>

#### 安装库文件

![Alt text](./img/dht11_lib.png)

#### 代码：
```c
#include <DHT.h>      // 1.调用dht11驱动库
#define DHTPIN D4     // 2.定义D4（GPIO2）口
//#define DHTPIN 2
#define DHTTYPE DHT11 // 3.说明模块类型dht11

DHT dht(DHTPIN, DHTTYPE);


void setup() {
  // put your setup code here, to run once:
  dht.begin();  // 开始测量
  Serial.begin(9600);   // 打开串口，设置波特率
}

void loop() {
  // put your main code here, to run repeatedly:
  delay(200); 
  float h = dht.readHumidity();
  float t = dht.readTemperature();

  Serial.print("当前温度：");
  Serial.print(t);
  Serial.println("℃");
  Serial.print("当前湿度：");
  Serial.print(h);
  Serial.println("%");

  delay(2000);
}
```

#### 输出
![Alt text](./img/dht11_code.png)



### 2.4 网络基础

计算机网络基础



### 2.5 调试助手



### 2.6 TCP服务


### 2.7 HTTP服务

## 三、案例实现

### 3.1 硬件程序

#### 设计思路

让NodeMCU与服务器端程序通信，服务器端程序接收来自于NodeMCU的数据以及向NodeMCU发送控制命令控制开关灯。在编写服务器程序前，我们使用网络调试助手来 等效替换 我的服务器端程序，进行前期的想法验证，探索验证通过网络通信确实能控制NodeMCU。

ESP8266之WiFiClient库学习：<https://blog.csdn.net/qq_41477556/article/details/112366202>

#### 程序代码

```c
//如果是nodemcu V3版，需要另外定义LED引脚
#define LED_BUILTIN 2 
#include <ESP8266WiFi.h>
//必须修改：填写你的WIFI帐号密码
const char* ssid = "ziroom601";
const char* password = "ziroomer002";

const char* host = "192.168.0.108";
const int port = 9002;//demo1 tcp 使用 9002端口

const char* id = "1234abcd";
int tick = 1000;

WiFiClient client;  //建立WiFi客户端对象

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  pinMode(LED_BUILTIN, OUTPUT);
  //连接WIFI
  WiFi.begin(ssid, password);
  //设置读取socket数据时等待时间为100ms（默认值为1000ms，会显得硬件响应很慢）
  client.setTimeout(100);

  //等待WIFI连接成功
  while (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi connecting...");
    delay(500);
  }
  Serial.println("WiFi connected!.");
}

void loop() {
  // put your main code here, to run repeatedly:
  if (client.connect(host, port))
  {
    // TCP连接成功
    Serial.println("host connected!");
    client.println("TCP client connected!");
  }
  else
  {
    // TCP连接异常
    Serial.println("host connecting...");
    delay(500);
  }

  while (client.connected()) {
    //      接收到TCP数据
    if (client.available())
    {
      String line = client.readStringUntil('\n');
      if (line == "1") {
        // 如果接收到1，就代表开灯
        Serial.println("command:open led.");
        // 设置该引脚为低电平
        digitalWrite(LED_BUILTIN, LOW);
        client.println("OK");
      }
      else if (line == "0") {
        // 如果接收到0，就代表关灯
        Serial.println("command:close led.");
        // 设置该引脚为高电平
        digitalWrite(LED_BUILTIN, HIGH);
        client.print("OK");
      }else{
        Serial.print("receive:"); 
        Serial.println(line); 
      }
    }
  }
}

```

### 3.2 后端服务

```js
var fs = require('fs');
var http = require('http');
var net = require('net');
var HTTP_PORT = "8000";
var TCP_PORT = "9002"
var TIMEOUT = 30 * 1000;//tcp客户端超过30秒没发数据判为超时并断开连接
var tcpClient = null;//tcp客户端

// 创建http server，并传入回调函数:
var httpServer = http.createServer(function (request, response) {
  // 回调函数接收request和response对象,
  // 获得HTTP请求的method和url:
  console.log(request.method + ': ' + request.url);
  switch (request.url) {
    case "/":
      //访问首页
      // 读取html文件并发送
      response.end(fs.readFileSync('./index.html'));
      break;
    case "/open":
      // 开灯命令
      openLed()
      response.end('succeed');
      break;
    case "/close":
      // 开灯命令
      closeLed()
      response.end('succeed');
      break;
    case "/data":
      // 获取数据
      var data = getData() || "无数据";

      var addr = "无连接";
      if (tcpClient && tcpClient.addr) {
        addr = tcpClient.addr
      }

      // 将结果转换成字符串再发出去
      var result = JSON.stringify({ addr: addr, data: data });
      response.end(result);
      break;
    default:
      response.writeHead(400);
      response.end();
      break;
  }
});

httpServer.listen(HTTP_PORT);
httpServer.on('error', onError);
httpServer.on('listening', onListening);

//创建TCP服务器
var tcpServer = net.createServer((socket) => {
  //connect
  var addr = socket.remoteAddress + ':' + socket.remotePort
  console.log(addr, " connect.", socket)
  socket.addr = addr
  tcpClient = socket

  // recieve data
  socket.on("data", data => {
    var str = addr + " --> " + data.toString('ascii') + '\n'
    console.log(str)
    socket.lastValue = data.toString('ascii')
  })

  // close
  socket.on('close', () => {
    console.log(addr, "close")
    tcpClient = null;
  })

  socket.on('error', (err) => {
    console.log("error", err)
    tcpClient = null;
  })

  socket.setTimeout(TIMEOUT);
  // 超过一定时间 没接收到数据，就主动断开连接。
  socket.on('timeout', () => {
    console.log(socket.id, socket.addr, 'socket timeout');
    socket.end();
    tcpClient = null;
  });
})

tcpServer.on("error", (err) => {
  console.log(err)
  tcpClient = null;
})

tcpServer.listen({ port: TCP_PORT, host: '0.0.0.0' }, () => {
  console.log('demo0.1 tcp server running on', tcpServer.address())
})

// 开灯
function openLed() {
  // 向TCP客户端发送1
  if (tcpClient) {
    tcpClient.write('1', 'ascii')
  }
  else {
    console.log("openLed error:not tcpClient.")
  }
}

// 关灯
function closeLed() {
  // 向TCP客户端发送0
  if (tcpClient) {
    tcpClient.write('0', 'ascii')
  }
  else {
    console.log("closeLed error:not tcpClient.")
  }
}

// 获取数据
function getData() {
  // 获取设备最新数据
  if (tcpClient) {
    return tcpClient.lastValue
  }
  else {
    console.log("getData error:not tcpClient.")
  }

}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }
  console.error(error)

}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = httpServer.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  console.log('http server Listening on ' + bind);
}
```

### 3.3 前端页面

![Alt text](./img/ledcontrol.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>案例实现：网页控制小灯</title>
</head>
<body>
    <h1>案例实现：网页控制小灯</h1>
    <div>设备地址：<p id="equipment-addr" style="display: inline;">无连接</p></div>
    <div>最新数据：<p id="equipment-data" style="display: inline;">无数据</p></div>
    <button id="open">开灯</button>
    <button id="close">关灯</button>
    <script>
        // 开灯函数，发起请求 GET /open
        function open() {
            let oReq = new XMLHttpRequest();
            oReq.open("GET", "/open");
            oReq.send();
        }

        // 关灯函数，发起请求 GET /close
        function close() {
            let oReq = new XMLHttpRequest();
            oReq.open("GET", "/close");
            oReq.send();
        }

        // 为按钮添加事件
        document.getElementById("open").addEventListener("click",open)
        document.getElementById("close").addEventListener("click",close)

        // 获取数据函数，发起请求 GET /data
        function getData() {
            let oReq = new XMLHttpRequest();
            oReq.open("GET", "/data");
            // 取得数据,并渲染到网页上
            oReq.onload = function callback() {
                let result = oReq.response;
                let obj = JSON.parse(result);
                document.getElementById("equipment-addr").textContent = obj.addr
                document.getElementById("equipment-data").textContent = obj.data

            }
            oReq.send();
        }
        //HTTP 轮询：每一秒拿一次数据。
        setInterval(getData,1000)
    </script>
</body>
</html>
```


## 四、优化方案

### 4.1 Bootstrap


### 4.2 Express


### 4.3 Echarts

### 4.4 Websocket

### 4.5 Mysql

